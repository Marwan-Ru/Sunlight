/*
#include "../cmake-build-release/_deps/spdlog-src/include/spdlog/spdlog.h"
#include "cores/API.h"
#include "parsers/SunEarthParser.h"
#include "maths/Ray.h"
#include "maths/RayHit.h"
#include "parsers/rapidobj.hpp"
#include "tests/intersection_test.h"
*/
/**
 * @brief Builds sunlight triangles from rapidobj results
 * @param parsedObj A *triangulated* rapidobj::Result object
 * @return corresponding vector of sunlight Triangles

std::vector<Triangle> getSunlightTriangleFromResults(rapidobj::Result& parsedObj) {
   // See https://github.com/guybrush77/rapidobj for a description of the structure of a rapidobj::Result object
   std::vector<Triangle> res;
   for (const auto& shape : parsedObj.shapes) {
      for (int i = 0; i < shape.mesh.indices.size(); i +=3) {
         // Getting each vertices index in the positions array
         const int p0 = shape.mesh.indices[i].position_index;
         const int p1 = shape.mesh.indices[i+1].position_index;
         const int p2 = shape.mesh.indices[i+2].position_index;
         const int pn = shape.mesh.indices[i].normal_index;

         // Getting each vertices positions, the array is flat and each vertice is composed of three floats
         auto a = TVec3d(parsedObj.attributes.positions[p0 * 3], parsedObj.attributes.positions[p0 * 3+1], parsedObj.attributes.positions[p0 * 3+2]);
         auto b = TVec3d(parsedObj.attributes.positions[p1 * 3], parsedObj.attributes.positions[p1 * 3+1], parsedObj.attributes.positions[p1 * 3+2]);
         auto c = TVec3d(parsedObj.attributes.positions[p2 * 3], parsedObj.attributes.positions[p2 * 3+1], parsedObj.attributes.positions[p2 * 3+2]);

         if (pn >= 0) { // Normals are optional in the obj format, we take care of the case where normals aren't specified
            auto n = TVec3d(parsedObj.attributes.normals[pn * 3], parsedObj.attributes.normals[pn * 3+1], parsedObj.attributes.normals[pn * 3+2]);
            res.emplace_back(a, b, c, std::to_string(i/3), shape.name, n);
         }else {
            res.emplace_back(a, b, c, std::to_string(i/3), shape.name);
         }
      }
   }
   return res;
}

void writeIntoObj(const std::vector<Triangle>& soup, const std::string& outFilePath) {
   std::ofstream outFile;
   outFile.open(outFilePath);
   if (outFile.is_open()) {
      outFile << "# This file has been generated by the sunlight library" << std::endl;

      // Writing vertices
      for (const auto& triangle : soup) {
         outFile << "v " << std::to_string(triangle.a.getX()) << " " << std::to_string(triangle.a.getY()) << " " << std::to_string(triangle.a.getZ()) << std::endl;
         outFile << "v " << std::to_string(triangle.b.getX()) << " " << std::to_string(triangle.b.getY()) << " " << std::to_string(triangle.b.getZ()) << std::endl;
         outFile << "v " << std::to_string(triangle.c.getX()) << " " << std::to_string(triangle.c.getY()) << " " << std::to_string(triangle.c.getZ()) << std::endl;
      }

      // Writing triangles
      for (int i=0; i < soup.size(); i++) {
         outFile << "f " << i * 3 + 1  << " " << (i * 3) + 2 << " " << (i * 3) + 3 << std::endl;
      }

      outFile.close();
   }
}
*/
int main(int argc, char **argv) {

/*
   if (argc < 2) {
      spdlog::error("Not enough arguments");
      exit(EXIT_FAILURE);
   }
   std::string objFilePath = argv[1];

   auto parsedObj = rapidobj::ParseFile(objFilePath);

   if (parsedObj.error) {
      spdlog::error("rapidObj error : {} on line {}", parsedObj.error.code.message(), parsedObj.error.line_num);
      exit(EXIT_FAILURE);
   }

   if (rapidobj::Triangulate(parsedObj)) {
      spdlog::info("Triangulation ok");
   } else {
      spdlog::error("Could not triangulate mesh from {} file", objFilePath);
      exit(EXIT_FAILURE);
   }

   size_t num_triangles{};
   for (const auto& shape : parsedObj.shapes) {
      num_triangles += shape.mesh.num_face_vertices.size();
   }
   spdlog::info("Number of shapes : {}", parsedObj.shapes.size());
   spdlog::info("Number of materials : {}", parsedObj.materials.size());
   spdlog::info("Number of triangles : {}", num_triangles);

   std::vector<Triangle> sunTriangles = getSunlightTriangleFromResults(parsedObj);

   SunEarthToolsParser sun_parser;
   sun_parser.loadSunpathFile("../datas/AnnualSunPath_Lyon.csv", 403200, 403224);
   const std::vector<SunDatas> sundataList = sun_parser.getSunDatas();

   std::cout << sundataList.size() << std::endl;

   spdlog::info("Number of sunlight triangles : {}", sunTriangles.size());
   std::vector<RayHit> hits;
   //for (const SunDatas& data : sundataList) {
   // Create all of my rays
   //std::vector<Ray> rays;

   std::vector<Triangle> hitTriangles;
   std::vector<Triangle> noHitTriangles;

   auto zenith = SunDatas("2015-01-01", TVec3d(), TVec3d(1, 0, 0));

   for (int i=0; i < sunTriangles.size(); i++) {
      std::clog << "\r Triangles remaining : " << sunTriangles.size() - i << std::flush;
      Ray r = constructRay(sunTriangles.at(i), zenith.direction);
      auto result = checkIntersectionWith(r, sunTriangles);
      if (!result.empty()) {
         hitTriangles.push_back(sunTriangles.at(i));
      } else {
         noHitTriangles.push_back(sunTriangles.at(i));
      }
   }

   writeIntoObj(hitTriangles, "occluded.obj");
   writeIntoObj(noHitTriangles, "notOccluded.obj" );
   std::clog << "\rDone !                             " << std::endl;
   */
   return 0;
}