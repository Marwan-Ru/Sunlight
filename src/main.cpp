#include "../cmake-build-release/_deps/spdlog-src/include/spdlog/spdlog.h"
#include "cores/API.h"
#include "parsers/SunEarthParser.h"
#include "maths/Ray.h"
#include "maths/RayHit.h"
#include "utils/rapidobj.hpp"

/**
 * @brief Builds sunlight triangles from rapidobj results
 * @param parsedObj A *triangulated* rapidobj::Result object
 * @return corresponding vector of sunlight Triangles
 */
std::vector<Triangle> getSunlightTriangleFromResults(rapidobj::Result& parsedObj) {
   // See https://github.com/guybrush77/rapidobj for a description of the structure of a rapidobj::Result object
   std::vector<Triangle> res;
   for (const auto& shape : parsedObj.shapes) {
      for (int i = 0; i < shape.mesh.indices.size(); i +=3) {
         // Getting each vertices index in the positions array
         const int p0 = shape.mesh.indices[i].position_index;
         const int p1 = shape.mesh.indices[i+1].position_index;
         const int p2 = shape.mesh.indices[i+2].position_index;
         const int pn = shape.mesh.indices[i].normal_index;

         // Getting each vertices positions, the array is flat and each vertice is composed of three floats
         auto a = TVec3d(parsedObj.attributes.positions[p0 * 3], parsedObj.attributes.positions[p0 * 3+1], parsedObj.attributes.positions[p0 * 3+2]);
         auto b = TVec3d(parsedObj.attributes.positions[p1 * 3], parsedObj.attributes.positions[p1 * 3+1], parsedObj.attributes.positions[p1 * 3+2]);
         auto c = TVec3d(parsedObj.attributes.positions[p2 * 3], parsedObj.attributes.positions[p2 * 3+1], parsedObj.attributes.positions[p2 * 3+2]);

         if (pn >= 0) { // Normals are optional in the obj format, we take care of the case where normals aren't specified
            auto n = TVec3d(parsedObj.attributes.normals[pn * 3], parsedObj.attributes.normals[pn * 3+1], parsedObj.attributes.normals[pn * 3+2]);
            res.emplace_back(a, b, c, std::to_string(i/3), shape.name, n);
         }else {
            res.emplace_back(a, b, c, std::to_string(i/3), shape.name);
         }
      }
   }
   return res;
}

void writeIntoObj(const std::vector<Triangle>& soup, const std::string& outFilePath) {
   std::ofstream outFile;
   outFile.open(outFilePath);
   if (outFile.is_open()) {
      outFile << "# This file has been generated by the sunlight library" << std::endl;

      // Writing vertices
      for (const auto& triangle : soup) {
         outFile << "v " << std::to_string(triangle.a.getX()) << " " << std::to_string(triangle.a.getY()) << " " << std::to_string(triangle.a.getZ()) << std::endl;
         outFile << "v " << std::to_string(triangle.b.getX()) << " " << std::to_string(triangle.b.getY()) << " " << std::to_string(triangle.b.getZ()) << std::endl;
         outFile << "v " << std::to_string(triangle.c.getX()) << " " << std::to_string(triangle.c.getY()) << " " << std::to_string(triangle.c.getZ()) << std::endl;
      }

      // Writing triangles
      for (int i=0; i < soup.size(); i++) {
         outFile << "f " << i * 3 + 1  << " " << (i * 3) + 2 << " " << (i * 3) + 3 << std::endl;
      }

      outFile.close();
   }
}

int main()
{
   std::string objFilePath = "../datas/FakeData-1.obj";



   auto parsedObj = rapidobj::ParseFile(objFilePath);

   if (parsedObj.error) {
      spdlog::error(parsedObj.error.code.message());
      exit(EXIT_FAILURE);
   }

   if (rapidobj::Triangulate(parsedObj)) {
      spdlog::info("Triangulation ok");
   } else {
      spdlog::error("Could not triangulate mesh from {} file", objFilePath);
      exit(EXIT_FAILURE);
   }

   size_t num_triangles{};
   for (const auto& shape : parsedObj.shapes) {
      num_triangles += shape.mesh.num_face_vertices.size();
   }
   std::cout << "Shapes:    " << parsedObj.shapes.size() << std::endl;
   std::cout << "Materials: " << parsedObj.materials.size() << std::endl;
   std::cout << "Triangles: " << num_triangles << std::endl;

   std::vector<Triangle> sunTriangles = getSunlightTriangleFromResults(parsedObj);

   SunEarthToolsParser sun_parser;
   sun_parser.loadSunpathFile("../datas/AnnualSunPath_Lyon.csv", 403200, 403224);
   const std::vector<SunDatas> sundataList = sun_parser.getSunDatas();

   std::cout << sundataList.size() << std::endl;

   std::cout << "Number of sunlight triangles : " << sunTriangles.size() << std::endl;
   std::vector<RayHit> hits;
   //for (const SunDatas& data : sundataList) {
       // Create all of my rays
   //std::vector<Ray> rays;

   std::vector<Triangle> hitTriangles;

   for (const Triangle& t : sunTriangles) {
      Ray r = constructRay(t, sundataList.at(0).direction);
      auto result = checkIntersectionWith(r, sunTriangles);
      if (!result.empty()) {
         hitTriangles.push_back(t);
      }
   }

   writeIntoObj(hitTriangles, "occluded3.obj");

   exit(EXIT_SUCCESS);
}
